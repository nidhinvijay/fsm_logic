<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>BTCUSD PnL Graph</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      .row {
        margin-bottom: 16px;
      }
      .chart-container {
        width: 100%;
        max-width: 1400px;
        height: 600px;
      }
      table {
        border-collapse: collapse;
        margin-top: 20px;
        font-size: 12px;
        width: 100%;
      }
      th,
      td {
        border: 1px solid #ccc;
        padding: 4px 6px;
        text-align: right;
      }
      th {
        background: #f0f0f0;
      }
      .table-wrap {
        max-width: 1400px;
        overflow-x: auto;
      }
      th.sticky {
        position: sticky;
        top: 0;
        z-index: 1;
      }
      td.left,
      th.left {
        text-align: left;
      }
    </style>
  </head>
  <body>
    <h2>BTCUSD PnL History (Paper + Live)</h2>

    <div class="row">
      <label for="dateInput">Date (YYYY-MM-DD): </label>
      <input id="dateInput" type="date" />
      <button id="loadBtn">Load</button>
      <label style="margin-left: 12px; font-size: 12px;">
        <input id="deltaMode" type="checkbox" />
        Show per-minute change (Δ)
      </label>
      <span id="status" style="margin-left: 10px; font-size: 12px;"></span>
    </div>

    <h3>Long Side (BUY)</h3>
    <div class="chart-container">
      <canvas id="longChart"></canvas>
    </div>

    <h3>Short Side (SELL)</h3>
    <div class="chart-container">
      <canvas id="shortChart"></canvas>
    </div>

    <h3>Trades (rows where a trade was closed)</h3>
    <div class="table-wrap">
      <table id="tradesTable">
        <thead>
          <tr>
            <th class="sticky left">Time (IST)</th>
            <th class="sticky">Side</th>
            <th class="sticky">Entry</th>
            <th class="sticky">Exit</th>
            <th class="sticky">Trade PnL</th>
            <th class="sticky">Paper LONG</th>
            <th class="sticky">Paper SHORT</th>
            <th class="sticky">Paper TOTAL</th>
            <th class="sticky">Live LONG</th>
            <th class="sticky">Live SHORT</th>
            <th class="sticky">Live TOTAL</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <script>
      const dateInput = document.getElementById('dateInput');
      const loadBtn = document.getElementById('loadBtn');
      const statusEl = document.getElementById('status');
      const deltaModeEl = document.getElementById('deltaMode');
      const tradesBody = document.querySelector('#tradesTable tbody');

      // default to today
      const today = new Date();
      const yyyy = today.getFullYear();
      const mm = String(today.getMonth() + 1).padStart(2, '0');
      const dd = String(today.getDate()).padStart(2, '0');
      dateInput.value = `${yyyy}-${mm}-${dd}`;

      let longChart;
      let shortChart;
      let currentRows = [];
      let currentChartRows = [];

      function fmtNum(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return '';
        return n.toFixed(2);
      }

      function addDays(dateStr, days) {
        const [yStr, mStr, dStr] = dateStr.split('-');
        const y = parseInt(yStr, 10);
        const m = parseInt(mStr, 10) - 1;
        const d = parseInt(dStr, 10);
        const dt = new Date(y, m, d);
        dt.setDate(dt.getDate() + days);
        const yy = dt.getFullYear();
        const mm = String(dt.getMonth() + 1).padStart(2, '0');
        const dd = String(dt.getDate()).padStart(2, '0');
        return `${yy}-${mm}-${dd}`;
      }

      function parseIst(timeIst) {
        // timeIst format: "YYYY-MM-DD HH:MM"
        const [dPart, tPart] = timeIst.split(' ');
        const [yStr, mStr, dStr] = dPart.split('-');
        const [hhStr, mmStr] = (tPart || '00:00').split(':');
        const yy = parseInt(yStr, 10);
        const mm = parseInt(mStr, 10) - 1;
        const dd = parseInt(dStr, 10);
        const hh = parseInt(hhStr, 10);
        const mi = parseInt(mmStr, 10);
        return new Date(yy, mm, dd, hh, mi, 0);
      }

      async function loadData() {
        const date = dateInput.value;
        if (!date) {
          statusEl.textContent = 'Please pick a date.';
          return;
        }

        statusEl.textContent = 'Loading...';

        try {
          // To show a "trading day" window 05:31 → next day 05:31,
          // we need to merge two calendar CSVs: selected date + next date.
          // Example: 2025-12-13 trading day includes 2025-12-14 03:05 IST.
          const nextDate = addDays(date, 1);

          const fetchRows = async (dateKey, required) => {
            const res = await fetch(
              `/pnl-history?date=${encodeURIComponent(dateKey)}`,
            );
            if (!res.ok) {
              if (required) {
                const err = await res.json().catch(() => ({}));
                throw new Error(`${res.status} ${err.error || ''}`);
              }
              return [];
            }
            const data = await res.json();
            return data.rows || [];
          };

          const [rowsA, rowsB] = await Promise.all([
            fetchRows(date, true),
            fetchRows(nextDate, false),
          ]);

          let rows = [...rowsA, ...rowsB];

          // Filter rows to custom "trading day" window:
          // from 05:31 IST of selected date to 05:31 IST of next day.
          // (This avoids the 05:30 reset minute.)
          if (rows.length) {
            const [yearStr, monthStr, dayStr] = date.split('-');
            const year = parseInt(yearStr, 10);
            const month = parseInt(monthStr, 10) - 1;
            const day = parseInt(dayStr, 10);

            const start = new Date(year, month, day, 5, 31, 0);
            const endExclusive = new Date(year, month, day, 5, 31, 0);
            endExclusive.setDate(endExclusive.getDate() + 1);

            rows = rows
              .filter((r) => {
                const dt = parseIst(r.timeIst);
                return dt >= start && dt < endExclusive;
              })
              .sort((a, b) => parseIst(a.timeIst) - parseIst(b.timeIst));
          }

          if (!rows.length) {
            statusEl.textContent = 'No data for this date.';
          } else {
            statusEl.textContent = `Loaded ${rows.length} rows (from ${date} + ${nextDate}).`;
          }

          currentRows = rows;

          // Charts should have exactly one point per minute; CSV can have extra rows
          // (e.g., one row per trade close). Keep the LAST row per minute.
          const byMinute = new Map();
          for (const r of rows) byMinute.set(r.timeIst, r);
          const chartRows = Array.from(byMinute.values()).sort(
            (a, b) => parseIst(a.timeIst) - parseIst(b.timeIst),
          );
          currentChartRows = chartRows;

          const labels = chartRows.map((r) => r.timeIst);
          const deltaMode = !!deltaModeEl.checked;

          const toDelta = (arr) => {
            if (!deltaMode) return arr;
            const out = [];
            for (let i = 0; i < arr.length; i += 1) {
              if (i === 0) out.push(0);
              else out.push(Number((arr[i] - arr[i - 1]).toFixed(2)));
            }
            return out;
          };

          const paperLong = toDelta(chartRows.map((r) => r.paperLongCumPnl));
          const paperShort = toDelta(chartRows.map((r) => r.paperShortCumPnl));
          const liveLong = toDelta(chartRows.map((r) => r.liveLongCumPnl));
          const liveShort = toDelta(chartRows.map((r) => r.liveShortCumPnl));

          const longCtx = document.getElementById('longChart').getContext('2d');
          const shortCtx = document
            .getElementById('shortChart')
            .getContext('2d');

          if (longChart) longChart.destroy();
          if (shortChart) shortChart.destroy();

          longChart = new Chart(longCtx, {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Paper LONG cum',
                  data: paperLong,
                  borderColor: 'blue',
                  fill: false,
                },
                {
                  label: 'Live LONG cum',
                  data: liveLong,
                  borderColor: 'orange',
                  borderDash: [5, 5],
                  fill: false,
                },
              ],
            },
            options: {
              responsive: true,
              interaction: { mode: 'index', intersect: false },
              stacked: false,
              scales: {
                x: {
                  ticks: {
                    maxRotation: 0,
                    minRotation: 0,
                    callback: function (value) {
                      const label = this.getLabelForValue(value);
                      const parts = String(label).split(' ');
                      return parts.length === 2 ? parts[1] : label;
                    },
                  },
                },
                y: {
                  title: {
                    display: true,
                    text: deltaMode ? 'Δ PnL per minute (LONG)' : 'Cum PnL (LONG)',
                  },
                },
              },
              plugins: {
                tooltip: {
                  callbacks: {
                    afterBody: (ctx) => {
                      const index = ctx[0].dataIndex;
                      const row = currentChartRows[index];
                      if (!row) return '';
                      // Trades are stored as separate rows in the CSV (can be multiple per minute),
                      // so look them up by minute label instead of relying on the chart row.
                      const timeKey = row.timeIst;
                      const tradeRows = currentRows.filter(
                        (r) => r.timeIst === timeKey && r.tradeSide,
                      );
                      if (!tradeRows.length) return '';

                      const parts = [];
                      for (const tr of tradeRows.slice(0, 3)) {
                        parts.push(`Trade: ${tr.tradeSide}`);
                        if (tr.tradeEntry != null && tr.tradeExit != null) {
                          parts.push(
                            `Entry: ${tr.tradeEntry.toFixed(
                              2,
                            )}, Exit: ${tr.tradeExit.toFixed(2)}`,
                          );
                        }
                        if (tr.tradePnl != null) {
                          parts.push(`Trade PnL: ${tr.tradePnl.toFixed(2)}`);
                        }
                      }
                      if (tradeRows.length > 3) {
                        parts.push(`(+${tradeRows.length - 3} more trades)`);
                      }
                      return parts;
                    },
                  },
                },
                zoom: {
                  zoom: {
                    wheel: { enabled: true },
                    pinch: { enabled: true },
                    mode: 'x',
                  },
                  pan: {
                    enabled: true,
                    mode: 'x',
                  },
                },
              },
            },
          });

          shortChart = new Chart(shortCtx, {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Paper SHORT cum',
                  data: paperShort,
                  borderColor: 'green',
                  fill: false,
                },
                {
                  label: 'Live SHORT cum',
                  data: liveShort,
                  borderColor: 'red',
                  borderDash: [5, 5],
                  fill: false,
                },
              ],
            },
            options: {
              responsive: true,
              interaction: { mode: 'index', intersect: false },
              stacked: false,
              scales: {
                x: {
                  ticks: {
                    maxRotation: 0,
                    minRotation: 0,
                    callback: function (value) {
                      const label = this.getLabelForValue(value);
                      const parts = String(label).split(' ');
                      return parts.length === 2 ? parts[1] : label;
                    },
                  },
                },
                y: {
                  title: {
                    display: true,
                    text: deltaMode ? 'Δ PnL per minute (SHORT)' : 'Cum PnL (SHORT)',
                  },
                },
              },
              plugins: {
                tooltip: {
                  callbacks: {
                    afterBody: (ctx) => {
                      const index = ctx[0].dataIndex;
                      const row = currentChartRows[index];
                      if (!row) return '';
                      const timeKey = row.timeIst;
                      const tradeRows = currentRows.filter(
                        (r) => r.timeIst === timeKey && r.tradeSide,
                      );
                      if (!tradeRows.length) return '';

                      const parts = [];
                      for (const tr of tradeRows.slice(0, 3)) {
                        parts.push(`Trade: ${tr.tradeSide}`);
                        if (tr.tradeEntry != null && tr.tradeExit != null) {
                          parts.push(
                            `Entry: ${tr.tradeEntry.toFixed(
                              2,
                            )}, Exit: ${tr.tradeExit.toFixed(2)}`,
                          );
                        }
                        if (tr.tradePnl != null) {
                          parts.push(`Trade PnL: ${tr.tradePnl.toFixed(2)}`);
                        }
                      }
                      if (tradeRows.length > 3) {
                        parts.push(`(+${tradeRows.length - 3} more trades)`);
                      }
                      return parts;
                    },
                  },
                },
                zoom: {
                  zoom: {
                    wheel: { enabled: true },
                    pinch: { enabled: true },
                    mode: 'x',
                  },
                  pan: {
                    enabled: true,
                    mode: 'x',
                  },
                },
              },
            },
          });

          // Fill trades table
          tradesBody.innerHTML = '';
          rows
            .filter((r) => r.tradeSide)
            .forEach((r) => {
              const tr = document.createElement('tr');
              const paperTotal = Number(r.paperLongCumPnl) + Number(r.paperShortCumPnl);
              const liveTotal = Number(r.liveLongCumPnl) + Number(r.liveShortCumPnl);
              const cells = [
                r.timeIst,
                r.tradeSide,
                r.tradeEntry != null ? fmtNum(r.tradeEntry) : '',
                r.tradeExit != null ? fmtNum(r.tradeExit) : '',
                r.tradePnl != null ? fmtNum(r.tradePnl) : '',
                fmtNum(r.paperLongCumPnl),
                fmtNum(r.paperShortCumPnl),
                fmtNum(paperTotal),
                fmtNum(r.liveLongCumPnl),
                fmtNum(r.liveShortCumPnl),
                fmtNum(liveTotal),
              ];
              cells.forEach((val, idx) => {
                const td = document.createElement('td');
                td.textContent = val;
                if (idx === 0) td.className = 'left';
                if (idx === 4) {
                  const pnl = Number(r.tradePnl);
                  if (Number.isFinite(pnl)) {
                    if (pnl > 0) td.style.color = 'green';
                    else if (pnl < 0) td.style.color = 'red';
                  }
                }
                tr.appendChild(td);
              });
              tradesBody.appendChild(tr);
            });
        } catch (err) {
          console.error(err);
          statusEl.textContent = 'Error fetching data.';
        }
      }

      loadBtn.addEventListener('click', loadData);
      deltaModeEl.addEventListener('change', loadData);
      // auto-load on open
      loadData();
    </script>
  </body>
  </html>
