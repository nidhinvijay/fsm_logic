<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Indian Options (Paper + Live)</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        max-width: 1400px;
        font-size: 12px;
      }
      th,
      td {
        border: 1px solid #ccc;
        padding: 6px 8px;
        text-align: left;
        vertical-align: top;
      }
      th {
        background: #f5f5f5;
      }
      .num {
        text-align: right;
        font-variant-numeric: tabular-nums;
      }
      code {
        background: #f6f8fa;
        padding: 2px 4px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <h2>Indian Options (Paper + Live)</h2>

    <p style="font-size: 12px;">
      This page shows per-instrument paper + live state. Zerodha ticks can be
      pushed to <code>POST /zerodha/tick</code> with
      <code>{"token":123,"ltp":12.34}</code>.
    </p>

    <p style="font-size: 12px;">
      Graph: <a href="/optionsgraph.html">/optionsgraph.html</a>
    </p>

	    <div style="margin: 10px 0; font-size: 12px;">
	      <button id="refreshBtn">Refresh</button>
	      <label style="margin-left: 10px;">
	        Date:
	        <input id="dateInput" type="date" />
	      </label>
	      <label style="margin-left: 10px;">
	        <input id="execToggle" type="checkbox" />
	        Enable Zerodha execution
	      </label>
	      <span id="status"></span>
	    </div>

    <table>
      <thead>
        <tr>
          <th>Graph</th>
          <th>TradingView</th>
          <th>Zerodha</th>
          <th>Token</th>
          <th class="num">LTP</th>
          <th>Paper State</th>
          <th>Paper Position</th>
          <th>Paper Triggers/Stops</th>
          <th class="num">Paper Cum</th>
          <th class="num">Paper Real</th>
          <th class="num">Paper Unrl</th>
          <th>Live State</th>
          <th>Live Position</th>
          <th class="num">Live Cum</th>
          <th class="num">Live Real</th>
          <th class="num">Live Unrl</th>
          <th>Live Last Close</th>
          <th>Lock</th>
          <th class="num">Trades</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>

    <h3 style="margin-top: 24px;">Recent Incoming Signals (Options)</h3>
    <p style="font-size: 12px; color: #666;">
      Filtered from <code>/recent-signals</code> where Routed To = OPTIONS.
    </p>
    <table>
      <thead>
        <tr>
          <th>Time (IST)</th>
          <th>Action</th>
          <th>StopPx</th>
          <th>Raw Symbol</th>
          <th>Mapped Symbol</th>
          <th>Note</th>
          <th>Message</th>
        </tr>
      </thead>
      <tbody id="signalsRows">
        <tr>
          <td colspan="7">No signals yet</td>
        </tr>
      </tbody>
    </table>

    <h3 style="margin-top: 24px;">Trades (per instrument)</h3>
    <p style="font-size: 12px; color: #666; margin-top: 6px;">
      Paper trades are from the paper FSM. Live trades are paired from live OPEN/CLOSE events.
    </p>
    <div id="tradesBySymbol"></div>

	    <script>
	      const statusEl = document.getElementById('status');
	      const rowsEl = document.getElementById('rows');
	      const refreshBtn = document.getElementById('refreshBtn');
	      const dateInputEl = document.getElementById('dateInput');
	      const execToggleEl = document.getElementById('execToggle');
	      const signalsRowsEl = document.getElementById('signalsRows');
	      const tradesBySymbolEl = document.getElementById('tradesBySymbol');
	      const rowByTradingview = new Map();

	      function fmtNum(value) {
	        if (value == null) return '';
	        const n = Number(value);
	        if (!Number.isFinite(n)) return '';
	        return n.toFixed(2);
	      }

	      async function loadExecState() {
	        try {
	          const res = await fetch('/options/execution');
	          const data = await res.json();
	          execToggleEl.checked = Boolean(data && data.enabled);
	        } catch {
	          // ignore
	        }
	      }

	      execToggleEl.addEventListener('change', async () => {
	        const enabled = execToggleEl.checked;
	        const token = window.prompt(
	          'Control token (OPTIONS_EXEC_CONTROL_TOKEN). Leave empty if not set on server:',
	        );
	        try {
	          const res = await fetch('/options/execution', {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ enabled, token: token || '' }),
	          });
	          const data = await res.json().catch(() => ({}));
	          if (!res.ok) {
	            execToggleEl.checked = !enabled;
	            alert(`Toggle failed: ${data && data.error ? data.error : res.status}`);
	          }
	        } catch (e) {
	          execToggleEl.checked = !enabled;
	          alert(`Toggle failed: ${String(e)}`);
	        }
	      });

      function fmtPos(p) {
        if (!p || !p.isOpen) return 'No position';
        const side = p.side ? String(p.side) : 'BUY';
        const entry = p.entryPrice != null ? fmtNum(p.entryPrice) : '';
        return `${side} @ ${entry}`;
      }

      function fmtTriggers(t) {
        if (!t) return '';
        const obj = {
          savedBUYLTP: t.savedBUYLTP,
          buyEntryTrigger: t.buyEntryTrigger,
          buyStop: t.buyStop,
          windowStartTs: t.windowStartTs,
          windowDurationMs: t.windowDurationMs,
          waitSourceState: t.waitSourceState,
        };
        return `<details><summary>view</summary><pre style="margin:6px 0; white-space:pre-wrap;">${JSON.stringify(
          obj,
          null,
          2,
        )}</pre></details>`;
      }

      function fmtLiveLastClose(live) {
        const trades = live && Array.isArray(live.recentTrades) ? live.recentTrades : [];
        const lastClose = [...trades].reverse().find((t) => t && t.action === 'CLOSE');
        if (!lastClose) return '';
        const exit = lastClose.exitPrice != null ? fmtNum(lastClose.exitPrice) : '';
        const pnl = lastClose.tradePnl != null ? fmtNum(lastClose.tradePnl) : '';
        const ts = (lastClose.tsIst || '').replace('T', ' ').slice(0, 16);
        return `${ts} exit=${exit} pnl=${pnl}`;
      }

      function fmtIstFromMs(tsMs) {
        if (typeof tsMs !== 'number' || !Number.isFinite(tsMs)) return '';
        return new Date(tsMs + 5.5 * 60 * 60 * 1000)
          .toISOString()
          .slice(0, 16)
          .replace('T', ' ');
      }

      function makeTable(params) {
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        params.headers.forEach((h) => {
          const th = document.createElement('th');
          th.textContent = h;
          trh.appendChild(th);
        });
        thead.appendChild(trh);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        if (!params.rows.length) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = params.headers.length;
          td.textContent = params.emptyText || 'No rows';
          tr.appendChild(td);
          tbody.appendChild(tr);
        } else {
          params.rows.forEach((r) => {
            const tr = document.createElement('tr');
            r.forEach((cell, idx) => {
              const td = document.createElement('td');
              td.textContent = cell;
              if (typeof params.numericFromIdx === 'number' && idx >= params.numericFromIdx) {
                td.className = 'num';
              }
              tr.appendChild(td);
            });
            tbody.appendChild(tr);
          });
        }
        table.appendChild(tbody);
        return table;
      }

      function pairLiveEventsToTrades(symbolId, events) {
        const trades = [];
        let open = null;
        for (const e of events || []) {
          if (!e || !e.action) continue;
          if (e.action === 'OPEN') open = e;
          else if (e.action === 'CLOSE') {
            trades.push({
              symbolId,
              openTsIst: open ? String(open.tsIst || '').replace('T', ' ').slice(0, 16) : '',
              closeTsIst: String(e.tsIst || '').replace('T', ' ').slice(0, 16),
              entryPrice: open ? open.entryPrice : e.entryPrice,
              exitPrice: e.exitPrice,
              tradePnl: e.tradePnl,
              cumPnlAfter: e.cumPnlAfter,
            });
            open = null;
          }
        }
        return trades;
      }

      function parseIst(timeIst) {
        const [dPart, tPart] = String(timeIst || '').split(' ');
        if (!dPart) return null;
        const [yStr, mStr, dStr] = dPart.split('-');
        const [hhStr, mmStr] = (tPart || '00:00').split(':');
        const yy = parseInt(yStr, 10);
        const mm = parseInt(mStr, 10) - 1;
        const dd = parseInt(dStr, 10);
        const hh = parseInt(hhStr, 10);
        const mi = parseInt(mmStr, 10);
        if (!Number.isFinite(yy) || !Number.isFinite(mm) || !Number.isFinite(dd)) return null;
        return new Date(yy, mm, dd, hh, mi, 0);
      }

      function inMarketWindow(timeIst, dateKey) {
        const dt = parseIst(timeIst);
        if (!dt) return false;
        const [yStr, mStr, dStr] = dateKey.split('-');
        const yy = parseInt(yStr, 10);
        const mm = parseInt(mStr, 10) - 1;
        const dd = parseInt(dStr, 10);
        const start = new Date(yy, mm, dd, 9, 15, 0);
        const endExclusive = new Date(yy, mm, dd, 15, 30, 0);
        return dt >= start && dt < endExclusive;
      }

      async function fetchHistoryRows(symbolId, dateKey) {
        const url = `/options/pnl-history?symbol=${encodeURIComponent(symbolId)}&date=${encodeURIComponent(dateKey)}`;
        const res = await fetch(url);
        if (!res.ok) return [];
        const data = await res.json();
        return Array.isArray(data.rows) ? data.rows : [];
      }

      function renderTradesBySymbol(stateRows, dateKey) {
        tradesBySymbolEl.innerHTML = '';
        const rows = Array.isArray(stateRows) ? stateRows : [];

        for (const r of rows) {
          const symbolId = r && r.tradingview ? r.tradingview : '';
          if (!symbolId) continue;

          const details = document.createElement('details');
          details.style.margin = '12px 0';

          const summary = document.createElement('summary');
          summary.style.cursor = 'pointer';
          summary.textContent = `${symbolId} (paper=${fmtNum(r.paper?.cumPnl)} live=${fmtNum(r.live?.cumPnl)})`;
          details.appendChild(summary);

          const wrap = document.createElement('div');
          wrap.style.marginTop = '10px';

          const paperTitle = document.createElement('div');
          paperTitle.style.fontWeight = 'bold';
          paperTitle.style.margin = '8px 0 6px';
          paperTitle.textContent = 'Paper trades';
          wrap.appendChild(paperTitle);
          const paperPlaceholder = document.createElement('div');
          paperPlaceholder.textContent = 'Loading...';
          wrap.appendChild(paperPlaceholder);

          const liveTitle = document.createElement('div');
          liveTitle.style.fontWeight = 'bold';
          liveTitle.style.margin = '14px 0 6px';
          liveTitle.textContent = 'Live trades';
          wrap.appendChild(liveTitle);
          const livePlaceholder = document.createElement('div');
          livePlaceholder.textContent = 'Loading...';
          wrap.appendChild(livePlaceholder);

          details.appendChild(wrap);
          tradesBySymbolEl.appendChild(details);

          // Load full-day trades from CSV history (not limited to in-memory buffers).
          (async () => {
            try {
              const historyRows = await fetchHistoryRows(symbolId, dateKey);
              const within = historyRows.filter((hr) => inMarketWindow(hr.timeIst, dateKey));

              const paperRows = within
                .filter((hr) => hr && hr.tradePnl != null)
                .map((hr) => [
                  hr.tradeOpenedAtMs != null ? fmtIstFromMs(Number(hr.tradeOpenedAtMs)) : '',
                  hr.tradeSide || '',
                  fmtNum(hr.tradeEntry),
                  fmtNum(hr.tradeExit),
                  fmtNum(hr.tradePnl),
                  hr.timeIst,
                ]);

              const liveRows = within
                .filter((hr) => hr && hr.liveTradePnl != null)
                .map((hr) => [
                  hr.liveTradeOpenedAtMs != null ? fmtIstFromMs(Number(hr.liveTradeOpenedAtMs)) : '',
                  fmtNum(hr.liveTradeEntry),
                  fmtNum(hr.liveTradeExit),
                  fmtNum(hr.liveTradePnl),
                  fmtNum(hr.liveTradeCumAfter),
                  hr.timeIst,
                ]);

              paperPlaceholder.replaceWith(
                makeTable({
                  headers: ['Open (IST)', 'Side', 'Entry', 'Exit', 'PnL', 'Close (IST)'],
                  rows: paperRows.slice(-50).reverse(),
                  emptyText: 'No paper trades yet',
                  numericFromIdx: 2,
                }),
              );
              livePlaceholder.replaceWith(
                makeTable({
                  headers: ['Open (IST)', 'Entry', 'Exit', 'PnL', 'Cum After', 'Close (IST)'],
                  rows: liveRows.slice(-50).reverse(),
                  emptyText: 'No live trades yet',
                  numericFromIdx: 1,
                }),
              );
            } catch (e) {
              paperPlaceholder.textContent = 'Error loading trades';
              livePlaceholder.textContent = 'Error loading trades';
            }
          })();
        }

        if (!tradesBySymbolEl.children.length) {
          const div = document.createElement('div');
          div.textContent = 'No instruments loaded.';
          tradesBySymbolEl.appendChild(div);
        }
      }

      function createRowCells() {
        const tr = document.createElement('tr');
        const cells = [];
        for (let i = 0; i < 19; i++) {
          const td = document.createElement('td');
          tr.appendChild(td);
          cells.push(td);
        }

        // numeric alignment columns
        [3, 4, 8, 9, 10, 13, 14, 15, 18].forEach((idx) => {
          cells[idx].className = 'num';
        });

        // graph link
        const a = document.createElement('a');
        a.textContent = 'graph';
        cells[0].appendChild(a);

        return { tr, cells, graphLink: a };
      }

      function getOrCreateRow(tradingview) {
        const existing = rowByTradingview.get(tradingview);
        if (existing) return existing;
        const created = createRowCells();
        rowByTradingview.set(tradingview, created);
        rowsEl.appendChild(created.tr);
        return created;
      }

      async function loadSignals() {
        try {
          const res = await fetch('/recent-signals');
          const data = await res.json();
          const rows = Array.isArray(data.rows) ? data.rows : [];
          const optRows = rows.filter((r) => r && r.routedTo === 'OPTIONS');

          signalsRowsEl.innerHTML = '';
          if (!optRows.length) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 7;
            td.textContent = 'No signals yet';
            tr.appendChild(td);
            signalsRowsEl.appendChild(tr);
            return;
          }

          optRows.slice(-50).forEach((r) => {
            const tr = document.createElement('tr');
            const cols = [
              (r.tsIst || '').replace('T', ' ').slice(0, 16),
              r.parsedAction || '',
              typeof r.stopPx === 'number' ? r.stopPx.toFixed(2) : '',
              r.rawSymbol || '',
              r.symbol || '',
              (r.note || '').slice(0, 80),
              (r.rawMessage || '').slice(0, 120),
            ];
            cols.forEach((v, idx) => {
              const td = document.createElement('td');
              td.textContent = v;
              if (idx >= 5) td.style.textAlign = 'left';
              tr.appendChild(td);
            });
            signalsRowsEl.appendChild(tr);
          });
        } catch (e) {
          // don't fail the whole page
        }
      }

      async function load() {
        statusEl.textContent = 'Refreshing...';

        try {
          const [instRes, stateRes] = await Promise.all([
            fetch('/options/instruments'),
            fetch('/options/state'),
          ]);
          const instData = await instRes.json();
          const stateData = await stateRes.json();
          const instruments = instData.instruments || [];
          const rows = stateData.rows || [];

          const byTv = new Map(instruments.map((i) => [i.tradingview, i]));
          const today = new Date();
          const yyyy = today.getFullYear();
          const mm = String(today.getMonth() + 1).padStart(2, '0');
          const dd = String(today.getDate()).padStart(2, '0');
          const todayKey = `${yyyy}-${mm}-${dd}`;

          for (const r of rows) {
            const meta = byTv.get(r.tradingview);
            const tradingview = r.tradingview || '';
            if (!tradingview) continue;

            const row = getOrCreateRow(tradingview);
            const graphHref = `/optionsgraph.html?symbol=${encodeURIComponent(
              tradingview,
            )}&date=${encodeURIComponent(todayKey)}`;

            row.graphLink.href = graphHref;
            row.cells[1].textContent = tradingview;
            row.cells[2].textContent = meta ? meta.zerodha : '';
            row.cells[3].textContent = meta ? String(meta.token ?? '') : '';
            row.cells[4].textContent = fmtNum(r.lastPrice);
            row.cells[5].textContent = r.paper?.state || '';
            row.cells[6].textContent = fmtPos(r.paper?.position);
            row.cells[7].innerHTML = fmtTriggers(r.paper?.triggers);
            row.cells[8].textContent = fmtNum(r.paper?.cumPnl);
            row.cells[9].textContent = fmtNum(r.paper?.realizedCumPnl);
            row.cells[10].textContent = fmtNum(r.paper?.unrealizedPnl);
            row.cells[11].textContent = r.live?.state || '';
            row.cells[12].textContent = fmtPos(r.live?.position);
            row.cells[13].textContent = fmtNum(r.live?.cumPnl);
            row.cells[14].textContent = fmtNum(r.live?.realizedCumPnl);
            row.cells[15].textContent = fmtNum(r.live?.unrealizedPnl);
            row.cells[16].textContent = fmtLiveLastClose(r.live);
            row.cells[17].textContent = r.live?.lockUntilTs
              ? new Date(r.live.lockUntilTs).toISOString()
              : '';
            row.cells[18].textContent =
              r.paper?.tradesCount != null ? String(r.paper.tradesCount) : '';
          }

          // Only render trades on explicit refresh / date change (not on 5s interval).

          const now = new Date();
          const hh = String(now.getHours()).padStart(2, '0');
          const min = String(now.getMinutes()).padStart(2, '0');
          const ss = String(now.getSeconds()).padStart(2, '0');
          statusEl.textContent = `Loaded ${rows.length} instruments @ ${hh}:${min}:${ss}.`;
        } catch (e) {
          statusEl.textContent = `Error: ${String(e)}`;
        }

        loadSignals();
      }

      async function loadTrades() {
        try {
          const dateKey = dateInputEl.value;
          if (!dateKey) return;
          const res = await fetch('/options/state');
          const data = await res.json();
          const rows = data.rows || [];
          renderTradesBySymbol(rows, dateKey);
        } catch (e) {
          // ignore
        }
      }

      refreshBtn.addEventListener('click', async () => {
        await load();
        await loadTrades();
      });

      dateInputEl.addEventListener('change', loadTrades);

      // default to today
	      (function initDate() {
	        const today = new Date();
	        const yyyy = today.getFullYear();
	        const mm = String(today.getMonth() + 1).padStart(2, '0');
	        const dd = String(today.getDate()).padStart(2, '0');
	        dateInputEl.value = `${yyyy}-${mm}-${dd}`;
	      })();

	      loadExecState();
	      load();
	      loadTrades();
      const UI_REFRESH_MS = 2000;
      setInterval(load, UI_REFRESH_MS);
    </script>
  </body>
</html>
